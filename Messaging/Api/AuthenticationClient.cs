// -------------------------------------
//  Domain		: IBT / Realtime.co
//  Author		: Nicholas Ventimiglia
//  Product		: Messaging and Storage
//  Published	: 2014
//  -------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using Foundation.Tasks;
using Realtime.Messaging.Internal;

namespace Realtime.Messaging
{


    /// <summary>
    /// ORTC server side API that contains ORTC factories as plug-ins.
    /// </summary>
    public class AuthenticationClient
    {

        #region static / const
        static HttpTaskService Client = new HttpTaskService("application/x-www-form-urlencoded");

        /// <summary>
        /// Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        /// <param name="url">ORTC server URL.</param>
        /// <param name="isCluster">Indicates whether the ORTC server is in a cluster.</param>
        /// <param name="authenticationToken">Authentication Token which is generated by the application server, for instance a unique session ID.</param>
        /// <param name="authenticationTokenIsPrivate">Indicates whether the authentication token is private (1) or not (0).</param>
        /// <param name="applicationKey">Application Key that was provided to you together with the ORTC service purchasing.</param>
        /// <param name="timeToLive">The authentication token time to live, in other words, the allowed activity time (in seconds).</param>
        /// <param name="privateKey">The private key provided to you together with the ORTC service purchasing.</param>
        /// <param name="permissions">The channels and their permissions (w: write/read or r: read, case sensitive).</param>
        /// <returns>True if the authentication was successful or false if it was not.</returns>
        public static UnityTask<bool> PostAuthentication(
            string url,
            bool isCluster,
            string authenticationToken,
            bool authenticationTokenIsPrivate,
            string applicationKey,
            int timeToLive,
            string privateKey,
            Dictionary<string, List<ChannelPermissions>> permissions)
        {
            var client = new AuthenticationClient
             {
                 Url = url,
                 IsCluster = isCluster,
                 AuthenticationToken = authenticationToken,
                 AuthenticationTokenIsPrivate = authenticationTokenIsPrivate,
                 ApplicationKey = applicationKey,
                 TimeToLive = timeToLive,
                 PrivateKey = privateKey,
                 Permissions = permissions,
             };
            return client.PostAuthentication();
        }

        #endregion

        #region public
        /// <summary>
        /// ORTC server URL.
        /// </summary>
        public string Url;
        /// <summary>
        /// Indicates whether the ORTC server is in a cluster.
        /// </summary>
        public bool IsCluster;
        /// <summary>
        /// Authentication Token which is generated by the application server, for instance a unique session ID.
        /// </summary>
        public string AuthenticationToken;
        /// <summary>
        /// Indicates whether the authentication token is private (1) or not (0).
        /// </summary>
        public bool AuthenticationTokenIsPrivate;
        /// <summary>
        /// Key that was provided to you together with the ORTC service purchasing.
        /// </summary>
        public string ApplicationKey;
        /// <summary>
        /// The authentication token time to live, in other words, the allowed activity time (in seconds).
        /// </summary>
        public int TimeToLive;
        /// <summary>
        /// The private key provided to you together with the ORTC service purchasing.
        /// </summary>
        public string PrivateKey;
        /// <summary>
        /// The channels and their permissions (w: write/read or r: read, case sensitive).
        /// </summary>
        public Dictionary<string, List<ChannelPermissions>> Permissions;

        /// <summary>
        /// Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        public UnityTask<bool> PostAuthentication()
        {
            #region Sanity Checks

            if (String.IsNullOrEmpty(Url))
            {
                return UnityTask.FailedTask<bool>(new OrtcException(OrtcExceptionReason.InvalidArguments, "URL is null or empty."));
            }
            if (String.IsNullOrEmpty(ApplicationKey))
            {
                return UnityTask.FailedTask<bool>(new OrtcException(OrtcExceptionReason.InvalidArguments, "Application Key is null or empty."));
            }
            if (String.IsNullOrEmpty(AuthenticationToken))
            {
                return UnityTask.FailedTask<bool>(new OrtcException(OrtcExceptionReason.InvalidArguments, "Authentication Token is null or empty."));
            }
            if (String.IsNullOrEmpty(PrivateKey))
            {
                return UnityTask.FailedTask<bool>(new OrtcException(OrtcExceptionReason.InvalidArguments, "Private Key is null or empty."));
            }
            if (Permissions != null && Permissions.Count == 0)
            {
                return UnityTask.FailedTask<bool>(new OrtcException(OrtcExceptionReason.InvalidArguments, "No permissions set."));
            }

            #endregion

            return UnityTask.RunCoroutine<bool>(PostAuthenticationAsync);
        }

        #endregion

        #region private

        IEnumerator PostAuthenticationAsync(UnityTask<bool> task)
        {
            var connectionUrl = Url;

            if (IsCluster)
            {
                var cTask = ClusterClient.GetClusterServerWithRetry(Url, ApplicationKey);
                yield return TaskManager.StartRoutine(cTask.WaitRoutine());
                if (cTask.IsFaulted)
                {
                    task.Exception = cTask.Exception;
                    task.Status = TaskStatus.Faulted;
                    yield break;
                }

                connectionUrl = cTask.Result;
            }

            connectionUrl = connectionUrl[connectionUrl.Length - 1] == '/' ? connectionUrl : connectionUrl + "/";

            var postParameters = String.Format("AT={0}&PVT={1}&AK={2}&TTL={3}&PK={4}", AuthenticationToken, AuthenticationTokenIsPrivate
                ? 1 : 0, ApplicationKey, TimeToLive, PrivateKey);

            if (Permissions != null && Permissions.Count > 0)
            {
                postParameters += String.Format("&TP={0}", Permissions.Count);
                foreach (var permission in Permissions)
                {
                    var permissionItemText = String.Format("{0}=", permission.Key);
                    var list = new List<ChannelPermissions>(permission.Value);
                    foreach (var permissionItemValue in list)
                    {
                        permissionItemText += ((char)permissionItemValue).ToString();
                    }

                    postParameters += String.Format("&{0}", permissionItemText);
                }
            }

            var hTask = Client.PostAsync(String.Format("{0}authenticate", connectionUrl), postParameters);
            yield return TaskManager.StartRoutine(hTask.WaitRoutine());

            if (hTask.IsFaulted)
            {
                task.Exception = hTask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            if (hTask.StatusCode == HttpStatusCode.Unauthorized)
            {
                task.Exception = new OrtcException(OrtcExceptionReason.Unauthorized, String.Format("Unable to connect to the authentication server {0}.", connectionUrl));
                task.Status = TaskStatus.Faulted;
                yield break;
            }


            task.Result = hTask.IsSuccess;
        }

        #endregion
    }
}
