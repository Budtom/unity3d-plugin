// -------------------------------------
//  Domain		: IBT / Realtime.co
//  Author		: Nicholas Ventimiglia
//  Product		: Messaging and Storage
//  Published	: 2014
//  -------------------------------------

using System;
using System.Collections;
using System.Text.RegularExpressions;
using Foundation.Tasks;
using Realtime.Messaging.Internal;

namespace Realtime.Messaging
{

    /// <summary>
    /// Static client for accessing presence data
    /// </summary>
    public class PresenceClient
    {
        #region static / const
        private const string SubscriptionsPattern = "^{\"subscriptions\":(?<subscriptions>\\d*),\"metadata\":{(?<metadata>.*)}}$";
        private const string MetadataPattern = "\"([^\"]*|[^:,]*)*\":(\\d*)";
        private const string MetadataDetailPattern = "\"(.*)\":(\\d*)";

        static HttpTaskService HttpClient = new HttpTaskService("application/x-www-form-urlencoded");


        /// <summary>
        /// Gets the subscriptions in the specified channel and if active the first 100 unique metadata.
        /// </summary>
        /// <param name="url">Server containing the presence service.</param>
        /// <param name="isCluster">Specifies if url is cluster.</param>
        /// <param name="authenticationToken">Authentication token with access to presence service.</param>
        /// <param name="applicationKey">Application key with access to presence service.</param>
        /// <param name="channel">Channel with presence data active.</param>
        public static UnityTask<Presence> GetPresence(string url, bool isCluster, string applicationKey, string authenticationToken, string channel)
        {
            var client = new PresenceClient
            {
                Url = url,
                IsCluster = isCluster,
                AuthenticationToken = authenticationToken,
                ApplicationKey = applicationKey,
                Channel = channel,
            };
            return client.GetPresence();
        }


        /// <summary>
        /// Enables presence for the specified channel with first 100 unique metadata if metadata is set to true.
        /// </summary>
        /// <param name="url">Server containing the presence service.</param>
        /// <param name="isCluster">Specifies if url is cluster.</param>
        /// <param name="applicationKey">Application key with access to presence service.</param>
        /// <param name="privateKey">The private key provided when the ORTC service is purchased.</param>
        /// <param name="channel">Channel to activate presence.</param>
        /// <param name="metadata">Defines if to collect first 100 unique metadata.</param>
        public static UnityTask<string> EnablePresence(string url, bool isCluster, string applicationKey, string privateKey, string channel, bool metadata)
        {
            var client = new PresenceClient
            {
                Url = url,
                IsCluster = isCluster,
                ApplicationKey = applicationKey,
                PrivateKey = privateKey,
                Channel = channel,
                MetaData = metadata,
            };
            return client.EnablePresence();
        }

        /// <summary>
        /// Disables presence for the specified channel.
        /// </summary>
        /// <param name="url">Server containing the presence service.</param>
        /// <param name="isCluster">Specifies if url is cluster.</param>
        /// <param name="applicationKey">Application key with access to presence service.</param>
        /// <param name="privateKey">The private key provided when the ORTC service is purchased.</param>
        /// <param name="channel">Channel to disable presence.</param>
        public static UnityTask<string> DisablePresence(string url, bool isCluster, string applicationKey, string privateKey, string channel)
        {
            var client = new PresenceClient
            {
                Url = url,
                IsCluster = isCluster,
                ApplicationKey = applicationKey,
                PrivateKey = privateKey,
                Channel = channel,
            };
            return client.DisablePresence();
        }

        #endregion

        #region public

        /// <summary>
        /// ORTC server URL.
        /// </summary>
        public string Url;
        /// <summary>
        /// Indicates whether the ORTC server is in a cluster.
        /// </summary>
        public bool IsCluster;
        /// <summary>
        /// Authentication Token which is generated by the application server, for instance a unique session ID.
        /// </summary>
        public string AuthenticationToken;
        /// <summary>
        /// Application Key that was provided to you together with the ORTC service purchasing.
        /// </summary>
        public string ApplicationKey;
        /// <summary>
        /// The private key provided to you together with the ORTC service purchasing.
        /// </summary>
        public string PrivateKey;
        /// <summary>
        /// The channel where the message will be sent.
        /// </summary>
        public string Channel;
        /// <summary>
        /// Defines if to collect first 100 unique metadata.
        /// </summary>
        public bool MetaData;
        
        /// <summary>
        /// Gets the subscriptions in the specified channel and if active the first 100 unique metadata.
        /// </summary>
        public UnityTask<Presence> GetPresence()
        {
            return UnityTask.RunCoroutine<Presence>(GetPresenceAsync);
        }


        /// <summary>
        /// Enables presence for the specified channel with first 100 unique metadata if metadata is set to true.
        /// </summary>
        public UnityTask<string> EnablePresence()
        {
            return UnityTask.RunCoroutine<string>(EnablePresenceAsync);
        }

        /// <summary>
        /// Disables presence for the specified channel.
        /// </summary>
        public UnityTask<string> DisablePresence()
        {
            return UnityTask.RunCoroutine<string>(DiablePresenceAsync);
        }

        #endregion

        #region private

        IEnumerator GetPresenceAsync(UnityTask<Presence> task)
        {
            var btask = BalancerClient.GetServerUrl(Url, IsCluster, ApplicationKey);
            yield return TaskManager.StartRoutine(btask.WaitRoutine());
            if (btask.IsFaulted)
            {
                task.Exception = btask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            var server = btask.Result;

            var presenceUrl = String.IsNullOrEmpty(server) ? server : server[server.Length - 1] == '/' ? server : server + "/";

            presenceUrl = String.Format("{0}presence/{1}/{2}/{3}", presenceUrl, ApplicationKey, AuthenticationToken, Channel);

            var htask = HttpClient.GetAsync(presenceUrl);
            yield return TaskManager.StartRoutine(htask.WaitRoutine());
            if (htask.IsFaulted)
            {
                task.Exception = htask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            task.Result = Deserialize(htask.Content);
        }

        IEnumerator EnablePresenceAsync(UnityTask<string> task)
        {
            var btask = BalancerClient.GetServerUrl(Url, IsCluster, ApplicationKey);
            yield return TaskManager.StartRoutine(btask.WaitRoutine());
            if (btask.IsFaulted)
            {
                task.Exception = btask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            var server = btask.Result;

            var presenceUrl = String.IsNullOrEmpty(server) ? server : server[server.Length - 1] == '/' ? server : server + "/";
            presenceUrl = String.Format("{0}presence/enable/{1}/{2}", presenceUrl, ApplicationKey, Channel);

            var content = String.Format("privatekey={0}", PrivateKey);

            if (MetaData)
            {
                content = String.Format("{0}&metadata=1", content);
            }

            var htask = HttpClient.PostAsync(presenceUrl, content);
            yield return TaskManager.StartRoutine(htask.WaitRoutine());
            if (htask.IsFaulted)
            {
                task.Exception = htask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            task.Result = htask.Content;
        }

        IEnumerator DiablePresenceAsync(UnityTask<string> task)
        {
            var btask = BalancerClient.GetServerUrl(Url, IsCluster, ApplicationKey);
            yield return TaskManager.StartRoutine(btask.WaitRoutine());
            if (btask.IsFaulted)
            {
                task.Exception = btask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            var server = btask.Result;
            var presenceUrl = String.IsNullOrEmpty(server) ? server : server[server.Length - 1] == '/' ? server : server + "/";
            presenceUrl = String.Format("{0}presence/disable/{1}/{2}", presenceUrl, ApplicationKey, Channel);
            var content = String.Format("privatekey={0}", PrivateKey);

            var htask = HttpClient.PostAsync(presenceUrl, content);
            yield return TaskManager.StartRoutine(htask.WaitRoutine());
            if (htask.IsFaulted)
            {
                task.Exception = htask.Exception;
                task.Status = TaskStatus.Faulted;
                yield break;
            }

            task.Result = htask.Content;
        }

        static Presence Deserialize(string message)
        {
            var result = new Presence();

            if (String.IsNullOrEmpty(message))
                return result;

            var json = message.Replace("\\\\\"", @"""");
            json = Regex.Unescape(json);

            var presenceMatch = Regex.Match(json, SubscriptionsPattern, RegexOptions.None);

            int subscriptions;

            if (int.TryParse(presenceMatch.Groups["subscriptions"].Value, out subscriptions))
            {
                var metadataContent = presenceMatch.Groups["metadata"].Value;

                var metadataRegex = new Regex(MetadataPattern, RegexOptions.None);
                foreach (Match metadata in metadataRegex.Matches(metadataContent))
                {
                    if (metadata.Groups.Count <= 1)
                        continue;

                    var metadataDetailMatch = Regex.Match(metadata.Groups[0].Value, MetadataDetailPattern, RegexOptions.None);

                    int metadataSubscriptions;

                    if (int.TryParse(metadataDetailMatch.Groups[2].Value, out metadataSubscriptions))
                    {
                        result.Metadata.Add(metadataDetailMatch.Groups[1].Value, metadataSubscriptions);
                    }
                }
            }

            result.Subscriptions = subscriptions;

            return result;
        }
        #endregion

    }
}
